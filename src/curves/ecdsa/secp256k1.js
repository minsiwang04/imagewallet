// Copyright 2018 Trinkler Software AG (Switzerland).
// Trinkler Software provides free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version <http://www.gnu.org/licenses/>.

// Module imports.
const elliptic = require('elliptic');
const utils = require('../utils')

// Set ECDSA context.
const secp256k1 = new elliptic.ec('secp256k1');

/**
 * Returns a private key dervied from a secret (256 bit string).
 *
 * @param {string} secret - A 256 bit string generated by a source with sufficient entropy.
 * @return A private key in hexadecimal representation.
 */
const createKey = (secret) => {
    // TODO validate string length = 32
    // TODO return array or hex ?
    return secp256k1.genKeyPair({
        entropy: secret
    }).priv.toString('hex');
};

const getPublicKey = (key) => {
    key = parseKey(key);

    return key.getPublic().encode('hex')
};

/**
 * Returns a digital signature of a hashed message.
 *
 * @param {string} key - A hexadecimal string representing a private key generated by this curve.
 * @param {string} messageHash - The hexadecimal string representation of a hashed message.
 * @return A digital signature.
 */
const signMessageHash = (key, messageHash) => {
    key = parseKey(key);

    return key.sign(messageHash);
};

/**
 * Verifies a hashed message signature .
 *
 * @param {string} key - A hexadecimal string representing a private key generated by this curve.
 * @param {string} messageHash - The hexadecimal string representation of a hashed message.
 * @return A digital signature.
 */
const verifyMessageHash = (messageHash, signature, key) => {
    signature = parseSignature(signature);
    key = parseKey(key);

    return key.verify(messageHash, signature);
};

const parseKey = (key) => {
    if (utils.isHex(key)) {
        key = secp256k1.keyFromPrivate(key);
    }
    return key;
}

const parseSignature = (sig) => {
    return sig;
    // if (utils.isHex(sig)) {
    //     key = secp256k1.keyFromPrivate(key);
    // }
    // return key;
}

module.exports = {
    createKey,
    getPublicKey,
    signMessageHash,
    verifyMessageHash
};
